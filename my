import os
import json
import logging
import asyncio
import re
from typing import List, Dict, Any

from dotenv import load_dotenv
from openai import AzureOpenAI
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

# Load environment variables
load_dotenv()

# Azure OpenAI configuration
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-12-01-preview")

if not AZURE_OPENAI_KEY:
    raise RuntimeError("âŒ AZURE_OPENAI_KEY not set in environment")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("FlightOps.MCPClient")

# Initialize Azure OpenAI client
client_azure = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version=AZURE_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

# Tool definitions
TOOLS = {
    "get_flight_basic_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Fetch basic flight information including carrier, flight number, stations, scheduled times, and flight status.",
    },
    "get_equipment_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get aircraft equipment details: aircraft type, tail number (registration), and configuration.",
    },
    "get_operation_times": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Return estimated and actual operation times: takeoff, landing, departure, arrival, and block times.",
    },
    "get_fuel_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Retrieve fuel summary including planned vs actual fuel consumption for the flight.",
    },
    "get_delay_summary": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get delay information including delay reasons, durations, and total delay time.",
    },
    "get_passenger_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get passenger count and connection information for the flight.",
    },
    "get_crew_info": {
        "args": ["carrier", "flight_number", "date_of_origin"],
        "desc": "Get crew connections and details for the flight.",
    },
    "health_check": {
        "args": [],
        "desc": "Check the health status of the MCP server and database connection.",
    },
    "raw_mongodb_query": {
        "args": ["query_json", "projection", "limit"],
        "desc": "Run a raw MongoDB query (JSON format) for debugging purposes.",
    },
    "run_aggregated_query": {
        "args": ["query_type", "carrier", "field", "start_date", "end_date", "filter_json"],
        "desc": "Run MongoDB aggregation queries (average, sum, min, max, count) with optional carrier or date filters."
    },
}

# ---------------------------------------------------------------------
#  SYSTEM PROMPTS
# ---------------------------------------------------------------------
def _build_tool_prompt() -> str:
    """Convert TOOLS dict into compact text to feed the LLM."""
    lines = []
    for name, meta in TOOLS.items():
        arg_str = ", ".join(meta["args"])
        lines.append(f"- {name}({arg_str}): {meta['desc']}")
    return "\n".join(lines)

SYSTEM_PROMPT_PLAN = f"""
You are an assistant that converts user questions into MCP tool calls.

Available tools:
{_build_tool_prompt()}

### Tool selection logic

1. **Use `run_aggregated_query`** when the user asks for:
   - counts, numbers, totals, sums, averages, minimums, or maximums
   - examples: "how many flights", "number of passengers", "average delay", "max flight time", "total fuel"
   - In such cases:
     - set `"query_type"` to one of ["count", "sum", "average", "min", "max"]
     - set `"field"` to the appropriate MongoDB path (e.g. "flightLegState.pax.passengerCount.count")
     - if the user gives a condition (e.g. "where delay > 30"), include it as `"filter_json"`
     - optionally include `"start_date"` and `"end_date"` for time ranges

2. **Use `raw_mongodb_query`** for:
   - retrieving lists of flights, filtered data, or detailed fields
   - when the question asks to "show", "list", "find", or "get" specific flight data
   - supports `"projection"` to reduce payload (LLM decides what to include)

3. **Use existing tools** (like get_flight_basic_info, get_delay_summary, etc.) for single-flight queries (where a flight number and date are specified).

---

### CRITICAL INSTRUCTION:
- **NEVER** use Markdown code fences (```json or ```) in your response
- **ALWAYS** return PURE JSON without any additional text or formatting
- Your entire response should be valid JSON that can be parsed directly

Example of CORRECT response:
{{
  "plan": [
    {{
      "tool": "get_flight_basic_info",
      "arguments": {{
        "carrier": "6E",
        "flight_number": "215",
        "date_of_origin": "2024-11-04"
      }}
    }}
  ]
}}

Remember: NO MARKDOWN, ONLY PURE JSON.
"""

SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer.
Be factual, short, and helpful. Focus on the key information that answers the user's question.
If there are multiple results, highlight the most important findings.
"""

# ---------------------------------------------------------------------
#  FLIGHTOPS MCP CLIENT CLASS
# ---------------------------------------------------------------------
class FlightOpsMCPClient:
    def __init__(self):
        self.session: ClientSession = None
        self._client_context = None

    # -------------------- CONNECTION HANDLERS -------------------------
    async def connect(self):
        try:
            logger.info("Connecting to MCP server via stdio...")
            
            # Get Python executable and server script path
            python_exe = os.getenv("PYTHON_EXECUTABLE", "python")
            server_script = os.path.join(os.path.dirname(__file__), "server.py")
            
            if not os.path.exists(server_script):
                raise FileNotFoundError(f"Server script not found at {server_script}")
            
            # Create server parameters for stdio transport
            server_params = StdioServerParameters(
                command=python_exe,
                args=[server_script]
            )
            
            self._client_context = stdio_client(server_params)
            read_stream, write_stream = await self._client_context.__aenter__()
            self.session = ClientSession(read_stream, write_stream)
            await self.session.__aenter__()
            await self.session.initialize()
            logger.info("âœ… Connected to MCP server successfully")
        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            raise

    async def disconnect(self):
        try:
            if self.session:
                await self.session.__aexit__(None, None, None)
            if self._client_context:
                await self._client_context.__aexit__(None, None, None)
            logger.info("Disconnected from MCP server")
        except Exception as e:
            logger.error(f"Error during disconnect: {e}")

    # -------------------- AZURE OPENAI WRAPPER -------------------------
    def _call_azure_openai(self, messages: list, temperature: float = 0.2, max_tokens: int = 2048) -> str:
        try:
            completion = client_azure.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return completion.choices[0].message.content
        except Exception as e:
            logger.error(f"Azure OpenAI API error: {e}")
            return json.dumps({"error": str(e)})

    # -------------------- MCP TOOL CALLS -------------------------
    async def list_tools(self) -> dict:
        """List all available tools from the MCP server."""
        try:
            if not self.session:
                await self.connect()
            tools_list = await self.session.list_tools()
            tools_dict = {tool.name: {"description": tool.description, "inputSchema": tool.inputSchema} for tool in tools_list.tools}
            return {"tools": tools_dict}
        except Exception as e:
            logger.error(f"Error listing tools: {e}")
            return {"error": str(e)}

    async def invoke_tool(self, tool_name: str, args: dict) -> dict:
        """Invoke a specific tool with arguments."""
        try:
            if not self.session:
                await self.connect()
            logger.info(f"Calling tool: {tool_name} with args: {args}")
            result = await self.session.call_tool(tool_name, args)

            if result.content:
                content_items = []
                for item in result.content:
                    if hasattr(item, 'text'):
                        try:
                            parsed_content = json.loads(item.text)
                            content_items.append(parsed_content)
                        except json.JSONDecodeError:
                            content_items.append(item.text)
                if len(content_items) == 1:
                    return content_items[0]
                return {"results": content_items}

            return {"error": "No content in response"}
        except Exception as e:
            logger.error(f"Error invoking tool {tool_name}: {e}")
            return {"error": str(e)}

    # -------------------- IMPROVED LLM PLANNING -------------------------
    def plan_tools(self, user_query: str) -> dict:
        """
        Ask the LLM to produce a valid JSON plan for which MCP tools to call.
        Handles Markdown code fences and malformed JSON gracefully.
        """
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_PLAN},
            {"role": "user", "content": user_query},
        ]

        content = self._call_azure_openai(messages, temperature=0.1)
        if not content:
            logger.warning("âš ï¸ LLM returned empty response during plan generation.")
            return {"plan": []}

        # More robust cleaning for Markdown code fences
        cleaned = content.strip()
        
        # Remove ```json and ``` markers
        if cleaned.startswith("```json"):
            cleaned = cleaned[7:].strip()
        elif cleaned.startswith("```"):
            cleaned = cleaned[3:].strip()
        
        if cleaned.endswith("```"):
            cleaned = cleaned[:-3].strip()
        
        # Also handle cases where there might be text before/after the JSON
        # Try to find JSON object boundaries
        start_idx = cleaned.find('{')
        end_idx = cleaned.rfind('}')
        
        if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
            cleaned = cleaned[start_idx:end_idx+1]
        
        logger.debug(f"ðŸ” Cleaned LLM plan output:\n{cleaned}")

        # Try to parse the cleaned content
        try:
            plan = json.loads(cleaned)
            if isinstance(plan, dict) and "plan" in plan:
                logger.info(f"âœ… Successfully parsed plan with {len(plan['plan'])} steps")
                return plan
            else:
                logger.warning("âš ï¸ LLM output did not contain 'plan' key.")
                return {"plan": []}
        except json.JSONDecodeError as e:
            logger.warning(f"âŒ Could not parse LLM plan output after cleaning: {e}")
            logger.debug(f"Raw content that failed to parse: {cleaned}")
            
            # Fallback: Try to extract basic flight info using regex for common patterns
            return self._fallback_plan(user_query)

    def _fallback_plan(self, user_query: str) -> dict:
        """
        Fallback method to create a basic plan when JSON parsing fails.
        Extracts flight numbers and carriers using regex patterns.
        """
        # Patterns to extract flight info from query
        flight_pattern = r'(\b(?:6E|AI|SG)\s*(\d{2,4})\b)'
        carrier_pattern = r'\b(6E|AI|SG)\b'
        date_pattern = r'\b(\d{4}-\d{2}-\d{2})\b'
        
        # Extract flight info
        flight_match = re.search(flight_pattern, user_query.upper())
        carrier_match = re.search(carrier_pattern, user_query.upper())
        date_match = re.search(date_pattern, user_query)
        
        carrier = carrier_match.group(1) if carrier_match else ""
        flight_number = flight_match.group(2) if flight_match else ""
        date_of_origin = date_match.group(1) if date_match else ""
        
        # Determine which tool to use based on query content
        query_lower = user_query.lower()
        
        if any(word in query_lower for word in ['base station', 'station', 'origin', 'destination', 'route', 'basic']):
            tool = "get_flight_basic_info"
        elif any(word in query_lower for word in ['aircraft', 'equipment', 'tail', 'registration', 'plane']):
            tool = "get_equipment_info"
        elif any(word in query_lower for word in ['time', 'schedule', 'departure', 'arrival', 'operation']):
            tool = "get_operation_times"
        elif any(word in query_lower for word in ['delay', 'late', 'on-time']):
            tool = "get_delay_summary"
        elif any(word in query_lower for word in ['fuel']):
            tool = "get_fuel_summary"
        elif any(word in query_lower for word in ['passenger', 'pax']):
            tool = "get_passenger_info"
        elif any(word in query_lower for word in ['crew']):
            tool = "get_crew_info"
        else:
            tool = "get_flight_basic_info"  # default
        
        plan = {
            "plan": [
                {
                    "tool": tool,
                    "arguments": {
                        "carrier": carrier,
                        "flight_number": flight_number,
                        "date_of_origin": date_of_origin
                    }
                }
            ]
        }
        
        logger.info(f"ðŸ”„ Using fallback plan: {tool} for {carrier} {flight_number}")
        return plan

    def summarize_results(self, user_query: str, plan: list, results: list) -> str:
        """Summarize the tool execution results using LLM."""
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARIZE},
            {"role": "user", "content": f"Original question: {user_query}"},
            {"role": "assistant", "content": f"Tools executed: {json.dumps(plan, indent=2)}"},
            {"role": "assistant", "content": f"Raw results: {json.dumps(results, indent=2)}"},
        ]
        summary = self._call_azure_openai(messages, temperature=0.3)
        return summary

    # -------------------- MAIN QUERY EXECUTION -------------------------
    async def run_query(self, user_query: str) -> dict:
        """
        Full flow:
        1. LLM plans which tools to call (including possible MongoDB query).
        2. Execute tools sequentially via MCP.
        3. Summarize results using LLM.
        """
        try:
            logger.info(f"User query: {user_query}")
            plan_data = self.plan_tools(user_query)
            plan = plan_data.get("plan", [])
            if not plan:
                return {"error": "LLM did not produce a valid tool plan."}

            results = []
            for step in plan:
                tool = step.get("tool")
                args = step.get("arguments", {})

                # Clean up bad args - convert None to empty string
                cleaned_args = {}
                for k, v in args.items():
                    if v is None:
                        cleaned_args[k] = ""
                    elif str(v).strip().lower() == "unknown":
                        cleaned_args[k] = ""
                    else:
                        cleaned_args[k] = v

                # Safety for MongoDB query
                if tool == "raw_mongodb_query":
                    query_json = cleaned_args.get("query_json", "")
                    if not query_json:
                        results.append({"raw_mongodb_query": {"error": "Empty query_json"}})
                        continue
                    # Enforce safe default limit
                    cleaned_args["limit"] = int(cleaned_args.get("limit", 10))
                    logger.info(f"Executing raw MongoDB query: {query_json}")

                resp = await self.invoke_tool(tool, cleaned_args)
                results.append({tool: resp})

            summary = self.summarize_results(user_query, plan, results)
            return {
                "plan": plan,
                "results": results, 
                "summary": summary,
                "success": True
            }
        except Exception as e:
            logger.error(f"Error in run_query: {e}")
            return {"error": str(e), "success": False}

    # -------------------- DIRECT TOOL INVOCATION -------------------------
    async def call_tool_directly(self, tool_name: str, **kwargs) -> dict:
        """Call a tool directly without planning."""
        try:
            # Clean arguments
            cleaned_args = {}
            for k, v in kwargs.items():
                if v is None:
                    cleaned_args[k] = ""
                elif str(v).strip().lower() == "unknown":
                    cleaned_args[k] = ""
                else:
                    cleaned_args[k] = v

            result = await self.invoke_tool(tool_name, cleaned_args)
            return {
                "tool": tool_name,
                "arguments": cleaned_args,
                "result": result,
                "success": True
            }
        except Exception as e:
            logger.error(f"Error calling tool {tool_name} directly: {e}")
            return {"error": str(e), "success": False}


# ---------------------------------------------------------------------
#  COMMAND LINE INTERFACE
# ---------------------------------------------------------------------
async def main():
    """Main function for command line usage."""
    client = FlightOpsMCPClient()
    
    try:
        print("ðŸš€ FlightOps MCP Client")
        print("Available commands:")
        print("  - Type a query (e.g., 'get basic info for flight 6E 215')")
        print("  - 'tools' - List available tools")
        print("  - 'health' - Check server health")
        print("  - 'exit' - Quit the client")
        print()
        
        while True:
            user_input = input("\nðŸ¤– Enter your query: ").strip()
            
            if user_input.lower() in ['exit', 'quit', 'q']:
                break
            elif user_input.lower() == 'tools':
                tools = await client.list_tools()
                print("\nðŸ“‹ Available Tools:")
                for tool_name, tool_info in tools.get('tools', {}).items():
                    print(f"  - {tool_name}: {tool_info.get('description', 'No description')}")
                continue
            elif user_input.lower() == 'health':
                result = await client.call_tool_directly('health_check')
                print("\nðŸ¥ Health Check Result:")
                print(json.dumps(result, indent=2))
                continue
            elif not user_input:
                continue
            
            # Process the query
            print(f"\nðŸ” Processing: {user_input}")
            result = await client.run_query(user_input)
            
            if result.get('success'):
                print(f"\nðŸ“Š Summary:")
                print("â”€" * 50)
                print(result['summary'])
                print("â”€" * 50)
                
                # Show raw results if requested
                show_raw = input("\nShow raw results? (y/n): ").strip().lower()
                if show_raw == 'y':
                    print("\nðŸ“„ Raw Results:")
                    print(json.dumps(result['results'], indent=2))
            else:
                print(f"\nâŒ Error: {result.get('error', 'Unknown error')}")
                
    except KeyboardInterrupt:
        print("\n\nðŸ‘‹ Goodbye!")
    except Exception as e:
        print(f"\nðŸ’¥ Unexpected error: {e}")
    finally:
        await client.disconnect()

# ---------------------------------------------------------------------
#  SIMPLE FUNCTION FOR EXTERNAL USE
# ---------------------------------------------------------------------
async def query_flight_data(query: str) -> str:
    """
    Simple function to query flight data and return summary.
    Useful for integration with other systems.
    """
    client = FlightOpsMCPClient()
    try:
        result = await client.run_query(query)
        if result.get('success'):
            return result['summary']
        else:
            return f"Error: {result.get('error', 'Unknown error')}"
    finally:
        await client.disconnect()

async def get_flight_info(carrier: str, flight_number: str, date: str = None) -> str:
    """
    Get basic flight information for a specific flight.
    """
    client = FlightOpsMCPClient()
    try:
        if date:
            query = f"Get basic information for flight {carrier} {flight_number} on {date}"
        else:
            query = f"Get basic information for flight {carrier} {flight_number}"
        
        result = await client.run_query(query)
        if result.get('success'):
            return result['summary']
        else:
            return f"Error: {result.get('error', 'Unknown error')}"
    finally:
        await client.disconnect()

if __name__ == "__main__":
    # Run the interactive client
    asyncio.run(main())
